11. 指针的秘密
>分析输出的结果

```c
int main()
{
    void *a[] = {(void *)1, (void *)2, (void *)3, (void *)4, (void *)5};
    printf("%d\n", *((int *)a + 1));
    printf("%d\n", *(int*)((char *)a + 1));
    printf("%lld\n", *((long long *)a + 3));
    printf("%d\n", *(char*)((short *)a + 4));
    printf("%#llx\n", *((long long *)((char *)a + 1) + 1));
    printf("%lld\n", *((long long *)((char *)a + 1) + 1));
    return 0;
}

```
|出题人|鲁樊栋  |
|--|--|
| 知识点一 | 指针 |
|知识点二|大小端|

Q1:分析每一个的输出

A1:

地址   | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07
------|------|------|------|------|------|------|------|------
a[0] | 0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00  // (void*)1
a[1] | 0x02 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00  // (void*)2
a[2] | 0x03 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00  // (void*)3
a[3] | 0x04 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00  // (void*)4
a[4] | 0x05 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00  // (void*)5

1. `*((int *)a + 1)`

	•``(int *)a``：将数组起始地址转换为int*（4字节步长）
	•``+1``：移动4字节（地址偏移4）
	•读取4字节：位于第一个元素的后半部分（全0）
	•输出：0​​
2. `` *(int*)((char *)a + 1)``
•``(char *)a + 1``：指向第一个元素的第二个字节
•转换为``int*``：读取4字节（从地址+1开始）
•小端序：00 00 00 00 → 0
•输出：0​​
3. ``*((long long *)a + 3)``
•``(long long *)a``：8字节步长
•+3：移动24字节（第4个元素）
•读取8字节：``(void*)4``→ 4
•​​输出：4​​
4. `` *(char*)((short *)a + 4)``
•``(short *)a``：2字节步长
•+4：移动8字节（第2个元素起始）
•转换为``char*``：读取第一个字节
•小端序：``(void*)2``的第一个字节是0x02
•输出：2​
5.`` printf("%#llx\n", *((long long *)((char *)a + 1) + 1));``
•``(char *)a + 1``：指向地址0x01
•``(long long *)((char *)a + 1)``：将地址0x01转换为long long*
•+ 1：移动8字节（``long long``大小）→ 地址0x09
•*((long long *)((char *)a + 1) + 1)：读取地址0x09处的8字节
小端序解释：0x0300000000000000

    •​​输出​​:0x0300000000000000

6. ``printf("%lld\n", *((long long *)((char *)a + 1) + 1));``
•小端序解释：0x0300000000000000→ 3 × 2⁵⁶ = 216172782113783808





