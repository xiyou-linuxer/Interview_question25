## 抗战 80 周年万岁！

请分析程序输出，并解释原因。

```c
int main(int argc, char **argv)
{
    int a = 1, b = argc, c = 0, d = 1;
    while (++a);
    if (b)
        printf("纪念抗战胜利80周年!\n");
    else if (c++ && ++d)
        printf("Hello Linux World!\n");
    printf("%s  %d %d %d\n", argv[a], b, c, d);
}
```

---

| **出题人** | **王力扬**                   |
| ---------- | ---------------------------- |
| 知识点 1   | int 类型的大小变化，整数溢出 |
| 知识点 2   | argc 与 argv 的理解          |
| 知识点 3   | ++i 与 i++的不同             |
| 知识点 4   | 二元运算符的运算顺序         |

---

Q1.argc 和 argv 是什么

Q2.a 的大小是多少？为什么？

Q3.b 的大小为什么是 1

Q4.为什么不输出 Hello Linux World!？

Q5.解释最后一个 printf 输出

---

A1：

-   `argc`（argument count）和`argv`（argument vector）是`main`函数的参数，用于处理命令行参数：
-   `argc`是一个整数，表示命令行参数的数量（包括程序本身名称）。例如，如果程序运行时没有额外参数，`argc`值为 1。
-   `argv`是一个指向字符串数组的指针，其中每个字符串是一个命令行参数。`argv[0]`是程序名称，`argv[1]`是第一个参数，依此类推。

A2：

-   a 的值是 0。原因如下：
-   代码中`a`被初始化为 1，然后进入`while (++a)`循环。这个循环会不断递增`a`（先递增再判断），直到`a`变为 0 时循环退出。
-   在 C 语言中，`int`类型通常为 32 位有符号整数，最大值是 2147483647。当`a`从 1 开始递增，达到最大值后溢出变为负数（-2147483648），并继续递增直到 0。此时循环条件为假，循环退出，因此`a`的最终值为 0。

A3:

-   b 的值是 1 是因为`b`被初始化为`argc`。如果程序运行时没有提供任何命令行参数（仅程序名称），`argc`的值为 1，因此`b`也为 1。如果有额外参数，`argc`会更大，但默认情况下没有参数时`b`为 1。

A4:

-   不输出"Hello Linux World!"的原因如下：
-   代码中的条件判断首先检查`if (b)`。由于`b`的值为 1（真），因此执行`printf("纪念抗战胜利70周年!\n")`，并跳过`else if`部分。
-   即使`b`为 0，`else if (c++ && ++d)`也不会为真：`c`初始值为 0，`c++`在条件判断中使用原始值 0（假），由于短路求值，`++d`不会执行，整个条件为假，因此不会输出"Hello Linux World!"。

A5:

-   最后一个`printf`输出如下：
-   `argv[a]`：由于`a`的值为 0，`argv[0]`是程序名称（例如`"./a.out"`或`"try.exe"`）。
-   `b`：值为`argc`，通常为 1（如果没有命令行参数）。
-   `c`：值为 0，因为`c`初始化为 0 且没有改变（`else if`未执行）。
-   `d`：值为 1，因为`d`初始化为 1 且没有改变（`else if`未执行）。
    因此，输出格式为：`程序名称  1 0 1`。例如，如果程序名为`"./a.out"`，输出为`"./a.out  1 0 1"`。
