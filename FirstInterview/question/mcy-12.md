#### 12.结构体！字符串？

尝试解释一下输出

```c

union U {
    long long l;
    char str[8];
};

struct S {
    int num1;
    union U u2;
    union U u3;
    short num4;
};

int main() {
    struct S s;
    s.num1 = 0x636C6577;
    s.u2.l = 0x78206F7420656D6F;
    s.u3.l = 0x756E696C756F7969;
    s.num4 = 0x78;
    printf("%s%s\nsize: %ld\n",(char*)&s,(char*)&s+8,sizeof(s));
    return 0;
}

```

------

| **出题人** | **孟昶羽**   |
| ---------- | ------------ |
| 知识点1 | 联合体的共享内存 |
| 知识点2 | 结构体的内存对齐 |
| 知识点3 | CPU的小端存储 |

------

Q1.解释一下输出 30%

Q2.你了解联合体的共享内存吗，请你详细说一说 20%

Q3.结构体有两种对齐方式,请你详细讲一讲 40%

Q4.请你详细说一说什么是小端存储 10%

------


---

A1：输出解释
- `num1 = 0x636C6577` → 小端存储 → 内存: `77 65 6C 63` → 字符: `"welc"`
- `u2.l = 0x78206F7420656D6F` → 小端 → 字符: `"ome to x"`
- `u3.l = 0x756E696C756F7969` → 小端 → 字符: `"iyoulinu"`
- `num4 = 0x78` → 低字节在低地址  
- `printf("%s%s", (char*)&s, (char*)&s+8)` → 拼接内存中字符输出

---

A2：联合体共享内存
- 所有成员共用同一块内存  
- 内存大小 = 最大成员大小  
- 写入一个成员会覆盖其他成员  
- 节省内存，常用于同一时刻只需要一个值的场景  

---

A3：结构体对齐
- **成员对齐**：每个成员按自身对齐要求放置，必要时插入内部填充  
- **整体对齐**：结构体总大小为最大成员对齐数的整数倍，必要时尾部填充  

---

A4：小端存储
- 低字节存低地址，高字节存高地址  
- 例：`int x=0x12345678` → 内存: `78 56 34 12`  
- 优点：方便逐字节运算和访问低位字节  
- 现代主流 CPU（x86/x86_64、ARM）默认小端

------